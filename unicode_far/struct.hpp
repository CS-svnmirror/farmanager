#ifndef __FARSTRUCT_HPP__
#define __FARSTRUCT_HPP__
/*
struct.hpp

все независимые структуры (которые содержат только простые типы)
*/
/*
Copyright (c) 1996 Eugene Roshal
Copyright (c) 2000 Far Group
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of the authors may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "farconst.hpp"
#include "UnicodeString.hpp"

struct PanelOptions
{
  int Type;
  int Visible;
  int Focus;
  int ViewMode;
  int SortMode;
  int SortOrder;
  int SortGroups;
  int ShowShortNames;
  int NumericSort;
};

struct Confirmation
{
  int Copy;
  int Move;
  int Drag;
  int Delete;
  int DeleteFolder;
  int Exit;
  int Esc;  // Для CheckForEsc
  /* $ 12.03.2002 VVM
    + Opt.EscTwiceToInterrupt
      Определяет поведение при прерывании длительной операции
      0 - второй ESC продолжает операцию
      1 - второй ESC прерывает операцию */
  int EscTwiceToInterrupt;
  int RemoveConnection;
  /* $ 23.05.2001
    +  Opt.Confirmation.AllowReedit - Флаг, который изменяет поведение открытия
      файла на редактирование если, данный файл уже редактируется. По умолчанию - 1
      0 - Если уже открытый файл не был изменен, то происходит переход к открытому редактору
          без дополнительных вопросов. Если файл был изменен, то задается вопрос, и в случае
          если выбрана вариант Reload, то загружается новая копия файла, при этом сделанные
          изменения теряются.
      1 - Так как было раньше. Задается вопрос и происходит переход либо уже к открытому файлу
          либо загружается новая версия редактора.
      */
  int AllowReedit;
  int HistoryClear;
  int RemoveSUBST;
  int RemoveHotPlug;
};

struct DizOptions
{
  string strListNames;
  int ROUpdate;
  int UpdateMode;
  int SetHidden;
  int StartPos;

  /*
  void Clear()
  {
    strListNames=L"";
    ROUpdate=0;
    UpdateMode=0;
    SetHidden=0;
    StartPos=0;
  }
  */
};

struct CodeXLAT
{
  DWORD Flags;       // дополнительные флаги

  int XLatEditorKey;
  int XLatCmdLineKey;
  int XLatDialogKey;
  int XLatFastFindKey;

  int XLatAltEditorKey;
  int XLatAltCmdLineKey;
  int XLatAltDialogKey;
  int XLatAltFastFindKey;

  /* $ 25.11.2000 IS
     Разграничитель слов из реестра для функции Xlat
  */
  string strWordDivForXlat;

  // первый байт - размер таблицы
  BYTE Table[2][81]; // [0] non-english буквы, [1] english буквы
  BYTE Rules[3][81]; // 3 по 40 правил:
                    //  [0] "если предыдущий символ латинский"
                    //  [1] "если предыдущий символ нелатинский символ"
                    //  [2] "если предыдущий символ не рус/lat"

  /*
  void Clear()
  {
    Flags=0;
    XLatEditorKey=0;
    XLatCmdLineKey=0;
    XLatDialogKey=0;
    XLatFastFindKey=0;
    XLatAltEditorKey=0;
    XLatAltCmdLineKey=0;
    XLatAltDialogKey=0;
    XLatAltFastFindKey=0;
    strWordDivForXlat=L"";
    memset(Table,0,sizeof(Table));
    memset(Rules,0,sizeof(Rules));
  }
  */
};

struct EditorOptions
{
	int TabSize;
	int ExpandTabs;
	int PersistentBlocks;
	int DelRemovesBlocks;
	int AutoIndent;
	int AutoDetectTable;
	int AnsiTableForNewFile;
	int AnsiTableAsDefault;
	int CursorBeyondEOL;
	int BSLikeDel;
	int CharCodeBase;
	int SavePos;
	int SaveShortPos;
	int F7Rules; // $ 28.11.2000 SVS - Правило на счет поиска в редакторе
	int AllowEmptySpaceAfterEof; // $ 21.06.2005 SKV - разрешить показывать пустое пространство после последней строки редактируемого файла.
	int ReadOnlyLock; // $ 29.11.2000 SVS - лочить файл при открытии в редакторе, если он имеет атрибуты R|S|H
	int UndoSize; // $ 03.12.2001 IS - размер буфера undo в редакторе
	int UseExternalEditor;
	DWORD FileSizeLimitLo;
	DWORD FileSizeLimitHi;
	int ShowKeyBar;
	int ShowTitleBar;

	string strWordDiv;

	void Clear ()
	{
		TabSize = 0;
		ExpandTabs = 0;
		PersistentBlocks = 0;
		DelRemovesBlocks = 0;
		AutoIndent = 0;
		AutoDetectTable = 0;
		AnsiTableForNewFile = 0;
		AnsiTableAsDefault = 0;
		CursorBeyondEOL = 0;
		BSLikeDel = 0;
		CharCodeBase = 0;
		SavePos = 0;
		SaveShortPos = 0;
		F7Rules = 0;
		AllowEmptySpaceAfterEof = 0;
		ReadOnlyLock = 0;
		UndoSize = 0;
		UseExternalEditor = 0;
		ShowKeyBar = 0;
		ShowTitleBar = 0;

		FileSizeLimitLo = 0;
		FileSizeLimitHi = 0;

		strWordDiv = L"";
	}

	void CopyTo (EditorOptions &dest)
	{
		dest.TabSize = TabSize;
		dest.ExpandTabs = ExpandTabs;
		dest.PersistentBlocks = PersistentBlocks;
		dest.DelRemovesBlocks = DelRemovesBlocks;
		dest.AutoIndent = AutoIndent;
		dest.AutoDetectTable = AutoDetectTable;
		dest.AnsiTableForNewFile = AnsiTableForNewFile;
		dest.AnsiTableAsDefault = AnsiTableAsDefault;
		dest.CursorBeyondEOL = CursorBeyondEOL;
		dest.BSLikeDel = BSLikeDel;
		dest.CharCodeBase = CharCodeBase;
		dest.SavePos = SavePos;
		dest.SaveShortPos = SaveShortPos;
		dest.F7Rules = F7Rules;
		dest.AllowEmptySpaceAfterEof = AllowEmptySpaceAfterEof;
		dest.ReadOnlyLock = ReadOnlyLock;
		dest.UndoSize = UndoSize;
		dest.UseExternalEditor = UseExternalEditor;
		dest.ShowKeyBar = ShowKeyBar;
		dest.ShowTitleBar = ShowTitleBar;
		dest.strWordDiv = strWordDiv;

		dest.FileSizeLimitLo = FileSizeLimitLo;
		dest.FileSizeLimitHi = FileSizeLimitHi;
	}
};

/* $ 29.03.2001 IS
     Тут следует хранить "локальные" настройки для программы просмотра
*/
struct ViewerOptions
{
  int TabSize;
  int AutoDetectTable;
  int ShowScrollbar;     // $ 18.07.2000 tran пара настроек для viewer
  int ShowArrows;
  int PersistentBlocks; // $ 14.05.2002 VVM Постоянные блоки во вьюере
  int ViewerIsWrap; // (Wrap|WordWarp)=1 | UnWrap=0
  int ViewerWrap; // Wrap=0|WordWarp=1
  int SaveViewerPos;
  int SaveViewerShortPos;
  int UseExternalViewer;
  int ShowKeyBar; // $ 15.07.2000 tran + ShowKeyBar
  int AnsiTableAsDefault;
  int ShowTitleBar;
};

// "Полиция"
struct PoliciesOptions {
  int DisabledOptions;  // разрешенность меню конфигурации
  int ShowHiddenDrives; // показывать скрытые логические диски
};

struct DialogsOptions{
  int   EditBlock;          // Постоянные блоки в строках ввода
  int   EditHistory;        // Добавлять в историю?
  int   AutoComplete;       // Разрешено автодополнение?
  int   EULBsClear;         // = 1 - BS в диалогах для UnChanged строки удаляет такую строку также, как и Del
  int   SelectFromHistory;  // = 0 then (ctrl-down в строке с историей курсор устанавливался на самую верхнюю строку)
  DWORD EditLine;           // общая информация о строке ввода (сейчас это пока... позволяет управлять выделением)
  int   MouseButton;        // Отключение восприятие правой/левой кнопки мышы как команд закрытия окна диалога
  int   DelRemovesBlocks;
  int   CBoxMaxHeight;      // максимальный размер открываемого списка (по умолчанию=8)
};

struct NowellOptions{
  int MoveRO;               // перед операцией Move снимать R/S/H атрибуты, после переноса - выставлять обратно
};

// Хранилище параметров поиска character table
struct FindCharTable
{
  int AllTables;
  int AnsiTable;
  int UnicodeTable;
  int TableNum;
};

struct ScreenSizes{
  COORD DeltaXY;            // на сколько поз. изменить размеры для распахнутого экрана
#if defined(DETECT_ALT_ENTER)
  /*
    Opt.WScreenSize - Windowed/Full Screen Size
       COORD[0].X - Windowed Width  mode 1
       COORD[0].Y - Windowed Height mode 1
       COORD[1].X - Windowed Width  mode 2
       COORD[1].Y - Windowed Height mode 2

       COORD[2].X - FullScreen Width  mode 1
       COORD[2].Y - FullScreen Height mode 1
       COORD[3].X - FullScreen Width  mode 2
       COORD[3].Y - FullScreen Height mode 2
  */
  int WScreenSizeSet;
  COORD WScreenSize[4];
#endif
};

struct LoadPluginsOptions
{
//  DWORD TypeLoadPlugins;       // see TYPELOADPLUGINSOPTIONS
  int MainPluginDir; // TRUE - использовать стандартный путь к основным плагинам
  int PluginsCacheOnly; // seting by '/co' switch, not saved in registry
  int PluginsPersonal;

  string strCustomPluginsPath;  // путь для поиска плагинов, указанный в /p
  string strPersonalPluginsPath;
  int SilentLoadPlugin; // при загрузке плагина с кривым...

  /*
  void Clear()
  {
    MainPluginDir=0;
    PluginsCacheOnly=0;
    PluginsPersonal=0;

    strCustomPluginsPath=L"";
    strPersonalPluginsPath=L"";
    SilentLoadPlugin=0;
  }
  */
};

struct FindFileOptions
{
  int FindFolders;
  int CollectFiles;
  int FileSearchMode;
  int SearchInFirst;
  int UseFilter;
  string strSearchInFirstSize;

  /*
  void Clear()
  {
    FindFolders=0;
    CollectFiles=0;
    FileSearchMode=0;
    SearchInFirst=0;
    strSearchInFirstSize=L"";
  }
  */
};

struct TreeOptions{
  int LocalDisk;         // Хранить файл структуры папок для локальных дисков
  int NetDisk;           // Хранить файл структуры папок для сетевых дисков
  int NetPath;           // Хранить файл структуры папок для сетевых путей
  int RemovableDisk;     // Хранить файл структуры папок для сменных дисков
  int MinTreeCount;      // Минимальное количество папок для сохранения дерева в файле.
  int AutoChangeFolder;  // автосмена папок при перемещении по дереву
  DWORD TreeFileAttr;    // файловые атрибуты для файлов-деревях
};

struct CopyMoveOptions{
  int UseSystemCopy;         // использовать системную функцию копирования
  int CopyOpened;            // копировать открытые на запись файлы
  int CopyShowTotal;         // показать общий индикатор копирования
  int MultiCopy;             // "разрешить мультикопирование/перемещение/создание связей"
  DWORD CopySecurityOptions; // для операции Move - что делать с опцией "Copy access rights"
  int CopyTimeRule;          // $ 30.01.2001 VVM  Показывает время копирования,оставшееся время и среднюю скорость
};

struct Options
{
  int Clock;
  int Mouse;
  int ShowKeyBar;
  int ScreenSaver;
  int ScreenSaverTime;
  int UsePromptFormat;
  string strPromptFormat;
  int AltGr;
  int UseVk_oem_x;
  int InactivityExit;
  int InactivityExitTime;
  int ShowHidden;
  int Highlight;

  string strLeftFolder;
  string strRightFolder;

  string strLeftCurFile;
  string strRightCurFile;

  int RightSelectedFirst;
  int LeftSelectedFirst;
  int SelectFolders;
  int ReverseSort;
  int ClearReadOnly;
  int SortFolderExt;
  int DeleteToRecycleBin;         // удалять в корзину?
  int DeleteToRecycleBinKillLink; // перед удалением папки в корзину кильнем вложенные симлинки.
  int WipeSymbol; // символ заполнитель для "ZAP-операции"

  struct CopyMoveOptions CMOpt;

  int MultiMakeDir; // Опция создания нескольких каталогов за один сеанс

  int CreateUppercaseFolders;
  int UseRegisteredTypes;

  int ViewerEditorClock;
  int OnlyEditorViewerUsed; // =1, если старт был /e или /v
  int SaveViewHistory;
  int ViewHistoryCount;

  string strExternalEditor;
  struct EditorOptions EdOpt;
  string strExternalViewer;
  struct ViewerOptions ViOpt;


  string strWordDiv; // $ 03.08.2000 SVS Разграничитель слов из реестра
  string strQuotedSymbols;
  DWORD QuotedName;
  int AutoSaveSetup;
  int SetupArgv; // количество каталогов в комюстроке ФАРа
  int ChangeDriveMode;
  int ChangeDriveDisconnetMode;

  int SaveHistory;
  int HistoryCount;
  int SaveFoldersHistory;
  int SavePluginFoldersHistory;
  int FoldersHistoryCount;
  int DialogsHistoryCount;

  struct FindFileOptions FindOpt;

  string strTempPath;
  int HeightDecrement;
  int WidthDecrement;

  string strPassiveFolder;

  int ShowColumnTitles;
  int ShowPanelStatus;
  int ShowPanelTotals;
  int ShowPanelFree;
  int ShowPanelScrollbar;
  int ShowMenuScrollbar; // $ 29.06.2000 SVS Добавлен атрибут показа Scroll Bar в меню.
  int ShowScreensNumber;
  int ShowSortMode;
  int ShowMenuBar;
  int FormatNumberSeparators;
  int CleanAscii;
  int NoGraphics;
  string strFolderInfoFiles;

  struct Confirmation Confirm;
  struct DizOptions Diz;

  int ShellRightLeftArrowsRule;
  struct PanelOptions LeftPanel;
  struct PanelOptions RightPanel;

  DWORD  AutoUpdateLimit; // выше этого количество автоматически не обновлять панели.
  int AutoUpdateRemoteDrive;

  string strLanguage;
  int SmallIcon;
  string strRegRoot;
  int PanelRightClickRule; // задает поведение правой клавиши мыши
  int PanelMiddleClickRule; // поведение средней кнопки мыши в панелях
  int PanelCtrlAltShiftRule; // задает поведение Ctrl-Alt-Shift для панелей.
  // Panel/CtrlFRule в реестре - задает поведение Ctrl-F. Если = 0, то штампуется файл как есть, иначе - с учетом отображения на панели
  int PanelCtrlFRule;
  /*
    битовые флаги, задают поведение Ctrl-Alt-Shift
     бит установлен - функция включена:
     0 - Panel
     1 - Edit
     2 - View
     3 - Help
     4 - Dialog
  */
  int AllCtrlAltShiftRule;

  int CASRule; // 18.12.2003 - Пробуем различать левый и правый CAS (попытка #1).
  /*
    задает поведение Esc для командной строки:
      =1 - Не изменять положение в History, если после Ctrl-E/Ctrl/-X
           нажали ESC (поведение - аля VC).
      =0 - поведение как и было - изменять положение в History
  */
  int CmdHistoryRule;

  DWORD ExcludeCmdHistory;
  int SubstPluginPrefix; // 1 = подстанавливать префикс плагина (для Ctrl-[ и ему подобные)
  int MaxPositionCache; // количество позиций в кэше сохранения
  int SetAttrFolderRules; // Правило на счет установки атрибутов на каталоги
  int ExceptRules; // Правило на счет вызова исключений
  int ExceptCallDebugger; // вызывать дебаггер при исключении
  int HotkeyRules; // Правило на счет выбора механизма хоткеев
  /*
   + Opt.ShiftsKeyRules - Правило на счет выбора механизма трансляции
     Alt-Буква для нелатинским буковок и символов "`-=[]\;',./" с
     модификаторами Alt-, Ctrl-, Alt-Shift-, Ctrl-Shift-, Ctrl-Alt-
  */
  int ShiftsKeyRules;
  int MacroReuseRules; // Правило на счет повторно использования забинденных клавиш
  DWORD DisableMacro; // параметры /m или /ma или /m....
  int IgnoreErrorBadPathName;

  DWORD KeyMacroCtrlDot; // аля KEY_CTRLDOT
  DWORD KeyMacroCtrlShiftDot; // аля KEY_CTRLSHIFTDOT
  int CursorSize[4];   // Размер курсора ФАРа

  struct CodeXLAT XLat;

  int ConsoleDetachKey; // Комбинация клавиш для детача Far'овской консоли от длятельного неинтерактивного процесса в ней запущенного.

  int UsePrintManager;

  string strHelpLanguage;
  int FullScreenHelp;
  int HelpTabSize;

  int HelpURLRules; // =0 отключить возможность запуска URL-приложений

  // запоминать логические диски и не опрашивать каждый раз. Для предотвращения "просыпания" "зеленых" винтов.
  int RememberLogicalDrives;
  /*
    будет влиять на:
        добавление файлов в историю с разным регистром
        добавление LastPositions в редакторе и вьюере
  */
  int FlagPosixSemantics;

  int MsWheelDelta; // задает смещение для прокрутки
  int MsWheelDeltaView;
  int MsWheelDeltaEdit;
  int MsWheelDeltaHelp;
  // горизонтальная прокрутка
  int MsHWheelDelta;
  int MsHWheelDeltaView;
  int MsHWheelDeltaEdit;

  /* $ 28.04.2001 VVM
    + Opt.SubstNameRule битовая маска:
      0 - если установлен, то опрашивать сменные диски при GetSubstName()
      1 - если установлен, то опрашивать все остальные при GetSubstName() */
  int SubstNameRule;

  /* $ 23.05.2001 AltF9
    + Opt.AltF9 Флаг позволяет выбрать механизм  работы комбинации Alt-F9
         (Изменение размера экрана) в оконном режиме. По умолчанию - 1.
      0 - использовать механизм, совместимый с FAR версии 1.70 beta 3 и
         ниже, т.е. переключение 25/50 линий.
      1 - использовать усовершенствованный механизм - окно FAR Manager
         будет переключаться с нормального на максимально доступный размер
         консольного окна и обратно.*/
  int AltF9;

  int PgUpChangeDisk;
  int ShowCheckingFile;
  int CloseConsoleRule;
  int CloseCDGate;       // автомонтирование CD

  DWORD LCIDSort;
  int RestoreCPAfterExecute;
  int ExecuteShowErrorMessage;
  int ExecuteUseAppPath;
  int ExecuteFullTitle;
  string strExecuteBatchType;

  DWORD PluginMaxReadData;
  int UseNumPad;
  int ScanJunction;

  DWORD ShowTimeoutDelFiles; // тайаут в процессе удаления (в ms)
  DWORD ShowTimeoutDACLFiles;
  int DelThreadPriority; // приоритет процесса удаления, по умолчанию = THREAD_PRIORITY_NORMAL

  //int CPAJHefuayor; // производное от "Close Plugin And Jump:
                  // Highly experimental feature, use at your own risk"

  string strDateFormat; // Для $Date
  struct LoadPluginsOptions LoadPlug;

  struct DialogsOptions Dialogs;
  struct PoliciesOptions Policies;
  struct NowellOptions Nowell;
  struct ScreenSizes ScrSize;

  struct FindCharTable CharTable; // Структура для запоминания параметров таблиц символов в поиске

  struct TreeOptions Tree;

  /*
  void Clear()
  {
    Clock=0;
    Mouse=0;
    ShowKeyBar=0;
    ScreenSaver=0;
    ScreenSaverTime=0;
    UsePromptFormat=0;
    strPromptFormat=L"";
    AltGr=0;
    UseVk_oem_x=0;
    InactivityExit=0;
    InactivityExitTime=0;
    ShowHidden=0;
    Highlight=0;

    strLeftFolder=L"";
    strRightFolder=L"";

    strLeftCurFile=L"";
    strRightCurFile=L"";

    RightSelectedFirst=0;
    LeftSelectedFirst=0;
    SelectFolders=0;
    ReverseSort=0;
    ClearReadOnly=0;
    SortFolderExt=0;
    DeleteToRecycleBin=0;
    WipeSymbol=0;

    memset(&CMOpt,0,sizeof(CMOpt));

    MultiMakeDir=0;
    CreateUppercaseFolders=0;
    UseRegisteredTypes=0;

    ViewerEditorClock=0;
    OnlyEditorViewerUsed=0;
    SaveViewHistory=0;
    ViewHistoryCount=0;

    strExternalEditor=L"";
    EdOpt.Clear();
    strExternalViewer=L"";
    memset(&ViOpt,0,sizeof(ViOpt));


    strWordDiv=L"";
    strQuotedSymbols=L"";
    QuotedName=0;
    AutoSaveSetup=0;
    SetupArgv=0;
    ChangeDriveMode=0;
    ChangeDriveDisconnetMode=0;

    SaveHistory=0;
    HistoryCount=0;
    SaveFoldersHistory=0;
    SavePluginFoldersHistory=0;
    FoldersHistoryCount=0;
    DialogsHistoryCount=0;

    FindOpt.Clear();

    strTempPath=L"";
    HeightDecrement=0;
    WidthDecrement=0;

    strPassiveFolder=L"";

    ShowColumnTitles=0;
    ShowPanelStatus=0;
    ShowPanelTotals=0;
    ShowPanelFree=0;
    ShowPanelScrollbar=0;
    ShowMenuScrollbar=0;
    ShowScreensNumber=0;
    ShowSortMode=0;
    ShowMenuBar=0;

    CleanAscii=0;
    NoGraphics=0;
    strFolderInfoFiles=L"";

    memset(&Confirm,0,sizeof(Confirm));
    Diz.Clear();
    memset(&LeftPanel,0,sizeof(LeftPanel));
    memset(&RightPanel,0,sizeof(RightPanel));

    AutoUpdateLimit=0;
    AutoUpdateRemoteDrive=0;

    strLanguage=L"";
    SmallIcon=0;
    strRegRoot=L"";
    PanelRightClickRule=0;
    PanelMiddleClickRule=0;
    PanelCtrlAltShiftRule=0;
    PanelCtrlFRule=0;
    AllCtrlAltShiftRule=0;
    CASRule=0;
    CmdHistoryRule=0;
    ExcludeCmdHistory=0;
    SubstPluginPrefix=0;
    MaxPositionCache=0;
    SetAttrFolderRules=0;
    ExceptRules=0;
    ExceptCallDebugger=0;
    HotkeyRules=0;
    ShiftsKeyRules=0;
    MacroReuseRules=0;
    IgnoreErrorBadPathName=0;

    KeyMacroCtrlDot=0;
    KeyMacroCtrlShiftDot=0;
    memset(CursorSize,0,sizeof(CursorSize));
    XLat.Clear();
    ConsoleDetachKey=0;

    UsePrintManager=0;

    strHelpLanguage=L"";
    FullScreenHelp=0;
    HelpTabSize=0;
    HelpURLRules=0;

    RememberLogicalDrives=0;
    FlagPosixSemantics=0;
    MsWheelDelta=0;
    MsWheelDeltaView=0;
    MsWheelDeltaEdit=0;
    MsWheelDeltaHelp=0;
    SubstNameRule=0;

    AltF9=0;
    PgUpChangeDisk=0;
    ShowCheckingFile=0;
    CloseConsoleRule=0;
    CloseCDGate=0;

    LCIDSort=0;
    RestoreCPAfterExecute=0;
    ExecuteShowErrorMessage=0;
    ExecuteUseAppPath=0;
    ExecuteFullTitle=0;
    strExecuteBatchType=L"";

    PluginMaxReadData=0;
    UseNumPad=0;
    ScanJunction=0;

    ShowTimeoutDelFiles=0;
    ShowTimeoutDACLFiles=0;
    DelThreadPriority=0;

    strDateFormat=L"";
    LoadPlug.Clear();

    memset(&Dialogs,0,sizeof(Dialogs));
    memset(&Policies,0,sizeof(Policies));
    memset(&Nowell,0,sizeof(Nowell));
    memset(&ScrSize,0,sizeof(ScrSize));
    memset(&CharTable,0,sizeof(CharTable));
    memset(&Tree,0,sizeof(Tree));
  }
  */
};

struct PluginHandle
{
  HANDLE hPlugin;
  class Plugin *pPlugin;
};

// for class Edit
struct ColorItem
{
  int StartPos;
  int EndPos;
  int Color;
};

enum enumHighlightDataColor
{
  HIGHLIGHTCOLOR_NORMAL = 0,
  HIGHLIGHTCOLOR_SELECTED,
  HIGHLIGHTCOLOR_UNDERCURSOR,
  HIGHLIGHTCOLOR_SELECTEDUNDERCURSOR,

  HIGHLIGHTCOLORTYPE_FILE = 0,
  HIGHLIGHTCOLORTYPE_MARKCHAR = 1,
};

struct HighlightDataColor
{
  WORD Color[2][4]; // [0=file, 1=mark][0=normal,1=selected,2=undercursor,3=selectedundercursor]; if HIBYTE == 0xFF then transparent
  DWORD MarkChar;
};

struct FAR_FIND_DATA_EX
{
	DWORD    dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	unsigned __int64 nFileSize;

	union {
		unsigned __int64 nPackSize; //same as reserved
		struct {
			DWORD dwReserved0;
			DWORD dwReserved1;
		};
	};

	string   strFileName;
	string   strAlternateFileName;

	void Clear()
	{
		dwFileAttributes=0;
		memset(&ftCreationTime,0,sizeof(ftCreationTime));
		memset(&ftLastAccessTime,0,sizeof(ftLastAccessTime));
		memset(&ftLastWriteTime,0,sizeof(ftLastWriteTime));
		nFileSize=_ui64(0);
		nPackSize=_ui64(0);
		strFileName=L"";
		strAlternateFileName=L"";
	}

	FAR_FIND_DATA_EX& operator=(const FAR_FIND_DATA_EX &ffdexCopy)
	{
		dwFileAttributes=ffdexCopy.dwFileAttributes;
		memcpy(&ftCreationTime,&ffdexCopy.ftCreationTime,sizeof(ftCreationTime));
		memcpy(&ftLastAccessTime,&ffdexCopy.ftLastAccessTime,sizeof(ftLastAccessTime));
		memcpy(&ftLastWriteTime,&ffdexCopy.ftLastWriteTime,sizeof(ftLastWriteTime));
		nFileSize=ffdexCopy.nFileSize;
		nPackSize=ffdexCopy.nPackSize;
		strFileName=ffdexCopy.strFileName;
		strAlternateFileName=ffdexCopy.strAlternateFileName;
		return *this;
	}
};


#endif // __FARSTRUCT_HPP__
