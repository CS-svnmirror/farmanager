<header>
tag=SMZ1
ver=2.7
</header>
<node>
id=1
lv=0
dt=Text
nm=Справка по изменениям в системе макросов
ctime=3551829092
mtime=3578058395
<article>
#_<markdown>
#_
#_Начиная с 30.09.2012 (Far 3.0.2851), в Far Manager вместо встроенного макроязыка
#_используется скриптовый язык Lua 5.1.
#_
#_Под макросом понимается Lua-скрипт и его мета-данные, такие как:
#_
#_* Области начала исполнения скрипта.
#_* Клавиши, инициирующие исполнение скрипта из данных областей.
#_* Предварительные условия для исполнения скрипта.
#_* Флаги времени исполнения: `EnableOutput` и `NoSendKeysToPlugins`.
#_
#_Функциональность
#_-----------------
#_
#_* Запись и воспроизведение макросов.
#_* Библиотеки функций Lua.
#_* Библиотеки функций LuaFAR (API плагинов).
#_* [Библиотеки функций макроязыка][API] (API макросов).
#_* API `MacroControl` для плагинов: все операции.
#_
#_[API]: 42.html
#_
</article>
</node>
<node>
id=42
lv=1
dt=Text
nm=Библиотеки функций макроязыка
ctime=3553243413
mtime=3578058786
<article>
#_<markdown>
#_Описание API в данном документе не является самодостаточным, оно является *дополняющим и уточняющим* к описанию свойств и функций объектов Фара в разделе [Макроязык][макроязык] Энциклопедии Фара.
#_
#_В идеале, API должен совпадать с оригинальным API макроязыка, за исключением случаев, перечисленных в статье [Изменения API в сравнении с макроязыком][APIchanges].
#_
#_[APIchanges]: 38.html
#_[макроязык]: http://api.farmanager.com/ru/macro/macrocmd/index.html
#_
#_@@@
#_
</article>
</node>
<node>
id=38
lv=2
dt=Text
nm=Изменения API в сравнении с макроязыком
ctime=3553185939
mtime=3555411576
<article>
#_<markdown>
#_
#_1. Все идентификаторы чувствительны к регистру символов.
#_1. Вместо прямого указания клавиш используется функция [`Keys`][Keys].
#_1. `$AKey -> Keys("AKey")`
#_1. `$SelWord -> Keys("SelWord")`
#_1. `$XLat -> Keys("XLat")`
#_1. `$Exit ->` ` `[`exit()`][exit]
#_1. Логические свойства имеют тип *boolean* (поэтому нет смысла сравнивать их с числом `0`).
#_1. Функция `prompt` может возвращать либо стринг, либо `false` (но никогда не число `0`).
#_1. Многие функции помещены в таблицу [`mf`] [mf] (сокращение от *macrofunctions*),
#_   например: `mf.abs`, `mf.fsplit` и т.д.
#_1. Функция `mf.fexist` возвращает булевое значение, а не число.
#_1. Функции [`mload`] [mload] и [`msave`] [msave] изменились, см. их описание.
#_1. Свойства, зависящие от контекста исполнения, находятся в таблице [`Object`][Object],
#_   например: `Object.CurPos`, `Object.Empty`.
#_1. `CheckHotkey -> Object.CheckHotkey`
#_1. `GetHotkey -> Object.GetHotkey`
#_1. Логические свойства проверки области исполнения находятся в таблице [`Area`][Area],
#_   например: `Area.Editor`, `Area.Shell`.
#_1. `Macro.Area -> Area.Current`.
#_1. `Dialog.AutoCompletion -> Area.DialogAutoCompletion`
#_1. `Shell.AutoCompletion  -> Area.ShellAutoCompletion`
#_1. `CallPlugin -> Plugin.Call`
#_1. `Dlg.Info.Id -> Dlg.Id`
#_1. `Dlg.Info.Owner -> Dlg.Owner`
#_1. `Far.Cfg.Get -> Far.Cfg_Get`. Эта функция возвращает стринг в случае успеха
#_    или `false` в случае неудачи.
#_1. `Far.Cfg.Err` больше не существует.
#_1. `FullScreen -> Far.FullScreen`
#_1. `IsUserAdmin -> Far.IsUserAdmin`
#_1. `History.Disable -> Far.DisableHistory`
#_1. `KbdLayout -> Far.KbdLayout`
#_1. `KeyBar.Show -> Far.KeyBar_Show`
#_1. `Window.Scroll -> Far.Window_Scroll`
#_1. `Menu.Info.Id -> Menu.Id`
#_1. `MsX`, `MsY`, `MsButton`, `MsCtrlState`, `MsEventFlags` -- см. таблицу [`Mouse`][Mouse]
#_1. `RCounter` больше не существует.
#_1. `Macro.Const`, `Macro.Func`, `Macro.Keyword` и `Macro.Var` больше не существуют.
#_
#_[exit]: 61.html
#_[mload]: 13.html
#_[msave]: 12.html
#_[mf]: 44.html
#_[Keys]: 4.html
#_[Area]: 36.html
#_[Object]: 45.html
#_[Mouse]: 59.html
#_
#_
</article>
</node>
<node>
id=20
lv=2
dt=Text
nm=Глобальные свойства и функции
ctime=3552221109
mtime=3568470175
<article>
#_**Свойства:** нет.
#_
#_**Функции:**
#_
#_  akey
#_  band, bnot, bor, bxor, lshift, rshift
#_  eval
#_  exit
#_  Keys
#_  mmode
#_  msgbox
#_  print
#_  printf
#_  prompt
#_
#_**Примечания:**
#_
#_1. Функции *band*, *bnot*, *bor*, *bxor*, *lshift* и *rshift* (операции с битами)
#_   - это глобальные ссылки на одноимённые функции из библиотеки *bit64*
#_   (см. LuaFAR manual).
#_
#_2. Функции *akey* и *mmode*, будучи вызваны из функции *condition* макроса, возвращают *false*.
#_
#_3. Для единообразия, все данные функции продублированы в таблице mf,
#_   например: *eval* и *mf.eval* - это одна и та же функция.
#_
#_@@@
#_<lua> Links = {
#_  exit="61.html",
#_  Keys="4.html",
#_  ["mf(?!\\.)"]="44.html",
#_  printf="60.html",
#_} </lua>
#_
</article>
</node>
<node>
id=61
lv=3
dt=Text
nm=exit
ctime=3555411121
mtime=3555411243
<article>
#_exit ()
#_
#_**Параметры:**
#_  нет
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Завершить работу макроса.
#_
</article>
</node>
<node>
id=4
lv=3
dt=Text
nm=Keys
ctime=3551902602
mtime=3561880602
<article>
#_Keys (...)
#_
#_**Параметры:**
#_  Один или больше аргументов типа string.
#_  Каждый аргумент может содержать несколько ключей, разделённых пробельными символами.
#_  Аргументы регистронезависимы.
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Послать один или более ключей Far Manager'у.
#_
#_**Примечания:**
#_
#_  1. Специальные ключи:
#_     *"AKey"*    - послать Far Manager'у клавишу, вызвавшую данный макрос.
#_     *"SelWord"* - выделить слово под курсором.
#_     *"XLat"*    - преобразовать слово под курсором.
#_
#_**Пример:**
#_  mykeys = "CtrlF5 Esc"
#_  Keys("AKey A b CtrlC ShiftEnter", mykeys)
#_
#_
</article>
</node>
<node>
id=60
lv=3
dt=Text
nm=printf
ctime=3554233087
mtime=3554233809
<article>
#_printf (fmt, ...)
#_
#_**Параметры:**
#_  fmt :  string
#_  ... :  0 или более параметров, в соответствии с форматом,
#_         заданным аргументом *fmt*.
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Работает аналогично функции макроязыка *print*, но с дополнительной
#_  возможностью форматирования. Правила форматирования описаны в мануале Lua.
#_
#_@@@
#_<lua> Links = {
#_  ["мануале Lua"]="http://www.lua.org/manual/5.1/manual.html#pdf-string.format",
#_} </lua>
#_
</article>
</node>
<node>
id=44
lv=2
dt=Text
nm=mf
ctime=3553243522
mtime=3581755140
<article>
#_**Свойства:** нет.
#_
#_**Функции:**
#_
#_  abs              len
#_  akey             lshift
#_  asc              max
#_  atoi             mdelete
#_  band             min
#_  beep             mload
#_  bnot             mmode
#_  bor              mod
#_  bxor             msave
#_  chr              msgbox
#_  clip             print
#_  date             printf
#_  env              prompt
#_  eval             replace
#_  exit             rindex
#_  fattr            rshift
#_  fexist           size2str
#_  float            sleep
#_  flock            string
#_  fmatch           strpad
#_  fsplit           strwrap
#_  GetMacroCopy     substr
#_  iif              testfolder
#_  index            trim
#_  int              ucase
#_  itoa             usermenu
#_  key              waitkey
#_  Keys             xlat
#_  lcase
#_
#_@@@
#_<lua> Links = {
#_  mload="13.html", msave="12.html", mdelete="15.html", usermenu="69.html",
#_  GetMacroCopy="72.html", eval="79.html",
#_} </lua>
#_
</article>
</node>
<node>
id=79
lv=3
dt=Text
nm=eval
ctime=3581755102
mtime=3582019799
<article>
#_<markdown>
#_Данная функция соответствует [описанию][1] в Энциклопедии Far Manager, но дополнительно, в режимах 0, 1, 3 параметр `S` может обозначать скрипт-файл, если этот параметр начинается с символа `@`.
#_
#_В этом случае параметр `S` должен иметь следующий формат:
#_
#_        @<имя файла-скрипта> [<параметры скрипта>]
#_
#_- В имени файла допустимо использование переменных окружения.
#_- Опциональные параметры скрипта представляют список Lua-выражений, разделённых запятыми.
#_
#_###Пример:###
#_```
#_    eval("@%MyFarScripts%\\calc.lua 'factorial', 3+5")
#_```
#_
#_[1]: http://api.farmanager.com/ru/macro/macrocmd/prop_func/general.html#eval
#_
#_
</article>
</node>
<node>
id=72
lv=3
dt=Text
nm=GetMacroCopy
ctime=3578176338
mtime=3578179212
<article>
#_macro = mf.GetMacroCopy (index)
#_
#_**Параметры:**
#_  index:  integer
#_
#_**Возвращает:**
#_  macro:  table или nil
#_
#_**Описание:**
#_  Функция *GetMacroCopy* возвращает копию таблицы загруженного макроса или обработчика
#_  события по его индексу во внутреннем  массиве (начиная от 1). Если индекс превышает
#_  размер массива, возвращается nil - таким образом можно определить конец массива.
#_
#_**Примечания:**
#_  * Неактивные (выгруженные или удалённые) элементы имеют поле "disabled" == true.
#_  * Отличить таблицу макроса от таблицы события можно по полю "area" типа string,
#_    которое присутствует только у макросов.
#_
</article>
</node>
<node>
id=15
lv=3
dt=Text
nm=mdelete
ctime=3552066075
mtime=3553243618
<article>
#_mf.mdelete (key, name)
#_
#_**Параметры:**
#_  key:  string
#_  name: string
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Функция *mdelete* удаляет значение или ключ из базы данных.
#_  Для удаления ключа следует указать параметр *name* == `"*"` (звёздочку).
#_
</article>
</node>
<node>
id=13
lv=3
dt=Text
nm=mload
ctime=3551993209
mtime=3553243630
<article>
#_ret = mf.mload (key, name)
#_
#_**Параметры:**
#_  key:   string
#_  name:  string
#_
#_**Возвращает:**
#_  ret:   number, string, boolean, table или nil.
#_
#_**Описание:**
#_  Функция *mload* читает значение из базы данных.
#_
#_
</article>
</node>
<node>
id=12
lv=3
dt=Text
nm=msave
ctime=3551993205
mtime=3574088210
<article>
#_mf.msave (key, name, value)
#_
#_**Параметры:**
#_  key:         string
#_  name:        string
#_  value:       number, string, boolean или table
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Функция *msave* сохраняет переданное значение в базу данных.
#_  При сохранении таблиц будут сохраняться только:
#_     ключи типов:    number, string, boolean.
#_     значения типов: number, string, boolean, table.
#_  Сохраняются и вложенные таблицы, при этом рекурсивные вложения пропускаются.
#_
</article>
</node>
<node>
id=69
lv=3
dt=Text
nm=usermenu
ctime=3571243204
mtime=3571397693
<article>
#_mf.usermenu (mode, filename)
#_
#_**Параметры:**
#_  mode:     number (0 по умолчанию)
#_  filename: string или nil
#_
#_**Возвращает:**
#_  ничего
#_
#_**Описание:**
#_  Открывает или создаёт пользовательское меню.
#_
#_  - *mode* может содержать бит 0x100, в этом случае функция возвращается
#_    только по закрытии пользовательского меню (синхронный вызов). Если
#_    данный бит равен нулю, то функция возвращается немедленно по открытии
#_    меню (асинхронный вызов).
#_
#_  Поведение функции в зависимости от величины младшего байта *mode*:
#_
#_    0: равносильно нажатию F2 в панелях; *filename* игнорируется.
#_    1: выводится диалог выбора пользовательского меню; *filename* игнорируется.
#_    2: файл открывается "как есть", т.е. по заданному *filename*.
#_    3: файл *filename* открывается в %farprofile%\Menus (папка создаётся
#_       автоматически).
#_
</article>
</node>
<node>
id=36
lv=2
dt=Text
nm=Area
ctime=3552736839
mtime=3553252985
<article>
#_**Area** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Current:               string
#_  Other:                 boolean
#_  Shell:                 boolean
#_  Viewer:                boolean
#_  Editor:                boolean
#_  Dialog:                boolean
#_  Search:                boolean
#_  Disks:                 boolean
#_  MainMenu:              boolean
#_  Menu:                  boolean
#_  Help:                  boolean
#_  Info:                  boolean
#_  QView:                 boolean
#_  Tree:                  boolean
#_  FindFolder:            boolean
#_  UserMenu:              boolean
#_  ShellAutoCompletion:   boolean
#_  DialogAutoCompletion:  boolean
#_
#_**Функции:**
#_
#_  Нет.
#_
</article>
</node>
<node>
id=46
lv=2
dt=Text
nm=APanel, PPanel
ctime=3553252677
mtime=3553260679
<article>
#_**APanel**, **PPanel** - таблицы со следующими полями:
#_
#_**Свойства:**
#_
#_  Bof:          boolean
#_  ColumnCount:  number
#_  CurPos:       number
#_  Current:      string
#_  DriveType:    number
#_  Empty:        boolean
#_  Eof:          boolean
#_  FilePanel:    boolean
#_  Filter:       boolean
#_  Folder:       boolean
#_  Format:       string
#_  Height:       number
#_  HostFile:     string
#_  ItemCount:    number
#_  Left:         boolean
#_  LFN:          boolean
#_  OPIFlags:     number
#_  Path:         string
#_  Path0:        string
#_  Plugin:       boolean
#_  Prefix:       string
#_  Root:         boolean
#_  SelCount:     number
#_  Selected:     boolean
#_  Type:         number
#_  UNCPath:      string
#_  Visible:      boolean
#_  Width:        number
#_
#_**Функции:**
#_
#_  Нет.
#_
</article>
</node>
<node>
id=57
lv=2
dt=Text
nm=Panel
ctime=3553252776
mtime=3586234479
<article>
#_**Panel** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Нет.
#_
#_**Функции:**
#_
#_  FAttr
#_  FExist
#_  Item
#_  Select
#_  SetPath
#_  SetPos
#_  SetPosIdx
#_  CustomSortMenu
#_  LoadCustomSortMode
#_  SetCustomSortMode
#_
#_**Примечание:**
#_  Функции CustomSortMenu, LoadCustomSortMode и SetCustomSortMode присутствуют только
#_  если в качестве движка Lua используется LuaJIT 2.
#_
#_@@@
#_<lua> Links = {
#_  LoadCustomSortMode="80.html",
#_  SetCustomSortMode="81.html",
#_  CustomSortMenu="82.html",
#_} </lua>
#_
</article>
</node>
<node>
id=82
lv=3
dt=Text
nm=CustomSortMenu
ctime=3585577926
mtime=3585633613
<article>
#_Panel.CustomSortMenu ()
#_
#_**Параметры:**
#_  Нет
#_
#_**Возвращает:**
#_  Ничего
#_
#_**Описание:**
#_  Функция выводит меню со списком загруженных пользовательских сортировок.
#_  Нажатие Enter устанавливает выбранный режим сортировки на активной панели,
#_  нажатие CtrlEnter - на пассивной, CtrlShiftEnter - на обеих.
#_
</article>
</node>
<node>
id=80
lv=3
dt=Text
nm=LoadCustomSortMode
ctime=3585324926
mtime=3586632404
<article>
#_Panel.LoadCustomSortMode (Mode, Settings)
#_
#_**Параметры:**
#_  Mode:         режим сортировки, целое число >=100 и <=0x7FFFFFFF
#_  Settings:     таблица, содержит следующие поля:
#_                  *Compare* (обязательное поле):
#_                     Функция, см. её описание ниже.
#_                  *DirectoriesFirst, SelectedFirst, RevertSorting, SortGroups:*
#_                     Данные опциональные поля задают соответствующие опции сортировки:
#_                     0 - опция выключена, 1 - опция включена, любое другое значение
#_                     или отсутствие данного поля означают "использовать текущую
#_                     установку Far Manager".
#_                  *InvertByDefault:*
#_                     Включать ли по умолчанию обратную сортировку.
#_                  *Indicator:*
#_                     Индикация режима сортировки на панели, строка из двух символов
#_                     (первый - для прямой, второй - для обратной сортировки).
#_                  *NoSortEqualsByName:*
#_                     По умолчанию, равные с точки зрения алгоритма сортировки элементы
#_                     сортируются по имени. Если это нежелательно, установите данное поле
#_                     в true.
#_                  *Description:*
#_                     Текстовое описание режима сортировки. Если данное поле задано,
#_                     оно используется в меню (см. Panel.CustomSortMenu).
#_                  *InitSort:*
#_                     Функция. Если задана, то вызывается перед началом сортировки.
#_                     Получает один параметр: таблицу *FarOptions* (см. ниже одноимённый
#_                     параметр функции *Compare*).
#_                  *EndSort:*
#_                     Функция. Если задана, то вызывается после окончания сортировки.
#_
#_                Если значение *Settings* равно nil или false, это означает выгрузку
#_                (удаление) данного режима сортировки.
#_
#_**Возвращает:**
#_  Ничего
#_
#_**Описание:**
#_  Функция загружает (или выгружает) пользовательский режим сортировки для панелей.
#_  Если режим загружен, он может быть установлен в панели посредством вызова функции
#_  Panel.SetCustomSortMode.
#_
#_**Функция Compare**
#_  result = Compare (Pi1, Pi2, FarOptions)
#_
#_  **Параметры:**
#_    Pi1 и Pi2  - сравниваемые элементы панели, структуры типа PluginPanelItem.
#_                 Reserved[0] содержит величину *Position* для элемента панели.
#_                 Reserved[1] содержит величину *SortGroup* для элемента панели.
#_    FarOptions - таблица, содержащая текущие опции сортировки панели в Far Manager
#_                 (все значения - булевые): *DirectoriesFirst, SelectedFirst,*
#_                 *RevertSorting, SortGroups, NumericSort, CaseSensitiveSort*.
#_
#_  **Возвращает:**
#_    result     - если 1-й элемент должен оказаться после прямой сортировки выше 2-го,
#_                 нужно возвратить отрицательное число, если ниже - положительное,
#_                 а если элементы по критерию сортировки равны - ноль.
#_
#_**Примечание:**
#_  Пользовательская сортировка использует библиотеку FFI от LuaJIT 2. Программирование
#_  с использованием LuaJIT FFI требует предварительного освоения документации.
#_
#_**Пример:**
#_  *-- Загрузить сортировку по длине имени файла.*
#_  local ffi = require "ffi"
#_  local C = ffi.C
#_  ffi.cdef [[
#_    int wcslen(const wchar_t`*`,const wchar_t`*`);
#_  ]]
#_  Panel.LoadCustomSortMode (100,
#_    { 
#_      Compare = function(p1, p2, opt)
#_        return C.wcslen(p1.FileName) - C.wcslen(p2.FileName)
#_      end;
#_      Indicator = "bB";
#_    })
#_
#_@@@
#_<lua> Links = {
#_  ["документации"]="http://luajit.org/ext_ffi.html",
#_  PluginPanelItem="http://api.farmanager.com/ru/structures/pluginpanelitem.html",
#_  ["Panel.SetCustomSortMode"]="81.html",
#_  ["Panel.CustomSortMenu"]="82.html",
#_} </lua>
#_
</article>
</node>
<node>
id=81
lv=3
dt=Text
nm=SetCustomSortMode
ctime=3585499487
mtime=3585600342
<article>
#_Panel.SetCustomSortMode (Mode, whatpanel)
#_
#_**Параметры:**
#_  Mode:         режим сортировки, целое число >=100 и <=0x7FFFFFFF
#_  whatpanel:    0=активная панель, 1=пассивная панель
#_
#_**Возвращает:**
#_  Ничего
#_
#_**Описание:**
#_  Если заданный режим сортировки загружен (см. Panel.LoadCustomSortMode),
#_  то будет произведена установка этого режима сортировки в заданной панели.
#_  Иначе не будет произведено никаких действий.
#_
#_**Пример:**
#_  *-- Установить заданную пользовательскую сортировку в активной панели.*
#_  Macro {
#_    description="Sort files by their name length";
#_    area="Shell"; key="CtrlShiftF1";
#_    action=function() Panel.SetCustomSortMode(100,0) end;
#_  }
#_
#_@@@
#_<lua> Links = {
#_  ["документации"]="http://luajit.org/ext_ffi.html",
#_  PluginPanelItem="http://api.farmanager.com/ru/structures/pluginpanelitem.html",
#_  ["Panel.LoadCustomSortMode"]="80.html",
#_} </lua>
#_
</article>
</node>
<node>
id=58
lv=2
dt=Text
nm=BM
ctime=3553686730
mtime=3553686801
<article>
#_**BM** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Нет.
#_
#_**Функции:**
#_
#_  Add
#_  Back
#_  Clear
#_  Del
#_  Get
#_  Goto
#_  Next
#_  Pop
#_  Prev
#_  Push
#_  Stat
#_
</article>
</node>
<node>
id=47
lv=2
dt=Text
nm=CmdLine
ctime=3553252699
mtime=3553260697
<article>
#_**CmdLine** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Bof:        boolean
#_  Empty:      boolean
#_  Eof:        boolean
#_  Selected:   boolean
#_  CurPos:     number
#_  ItemCount:  number
#_  Value:      string
#_
#_**Функции:**
#_
#_  Нет.
#_
</article>
</node>
<node>
id=51
lv=2
dt=Text
nm=Dlg
ctime=3553252729
mtime=3553260711
<article>
#_**Dlg** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  CurPos:     number
#_  Id:         string (GUID)
#_  Owner:      string (GUID)
#_  ItemCount:  number
#_  ItemType:   number
#_  PrevPos:    number
#_
#_**Функции:**
#_
#_  GetValue
#_  SetFocus
#_
#_
</article>
</node>
<node>
id=48
lv=2
dt=Text
nm=Drv
ctime=3553252704
mtime=3553260726
<article>
#_**Drv** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  ShowMode:  number
#_  ShowPos:   number
#_
#_**Функции:**
#_
#_  Нет.
#_
</article>
</node>
<node>
id=52
lv=2
dt=Text
nm=Editor
ctime=3553252733
mtime=3553260742
<article>
#_**Editor** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  CurLine:   number
#_  CurPos:    number
#_  FileName:  string
#_  Lines:     number
#_  RealPos:   number
#_  SelValue:  string
#_  State:     number
#_  Value:     string
#_
#_**Функции:**
#_
#_  DelLine
#_  GetStr
#_  InsStr
#_  Pos
#_  Sel
#_  Set
#_  SetStr
#_  SetTitle
#_  Undo
#_
</article>
</node>
<node>
id=54
lv=2
dt=Text
nm=Far
ctime=3553252749
mtime=3555391522
<article>
#_**Far** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  FullScreen:      boolean
#_  Height:          number
#_  IsUserAdmin:     boolean
#_  PID:             number
#_  Title:           string
#_  UpTime:          number
#_  Width:           number
#_
#_**Функции:**
#_
#_  Cfg_Get
#_  DisableHistory
#_  KbdLayout
#_  KeyBar_Show
#_  Window_Scroll
#_
</article>
</node>
<node>
id=49
lv=2
dt=Text
nm=Help
ctime=3553252714
mtime=3553260782
<article>
#_**Help** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  FileName:  string
#_  SelTopic:  string
#_  Topic:     string
#_
#_**Функции:**
#_
#_  Нет.
#_
</article>
</node>
<node>
id=53
lv=2
dt=Text
nm=Menu
ctime=3553252746
mtime=3553678755
<article>
#_**Menu** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Id:     string (GUID)
#_  Value:  string
#_
#_**Функции:**
#_
#_  Filter
#_  FilterStr
#_  GetValue
#_  ItemStatus
#_  Select
#_  Show
#_
</article>
</node>
<node>
id=59
lv=2
dt=Text
nm=Mouse
ctime=3553790262
mtime=3563004403
<article>
#_**Mouse** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  X:              number
#_  Y:              number 
#_  Button:         number
#_  CtrlState:      number
#_  EventFlags:     number
#_  LastCtrlState:  number
#_
#_**Функции:**
#_
#_  Нет.
#_
#_**Примечание:**
#_
#_  *Mouse.LastCtrlState* отличается от *Mouse.CtrlState* тем, что обновляется
#_  как по событиям от мыши, так и по клавиатурным событиям.
#_
</article>
</node>
<node>
id=45
lv=2
dt=Text
nm=Object
ctime=3553245384
mtime=3563291684
<article>
#_**Свойства, зависящие от контекста исполнения.**
#_
#_**Object**: таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Bof:         boolean
#_  CurPos:      number
#_  Empty:       boolean
#_  Eof:         boolean
#_  Height:      number
#_  ItemCount:   number
#_  Selected:    boolean
#_  Title:       string
#_  Width:       number
#_
#_**Функции:**
#_
#_  CheckHotkey
#_  GetHotkey
#_
#_
</article>
</node>
<node>
id=56
lv=2
dt=Text
nm=Plugin
ctime=3553252766
mtime=3560706521
<article>
#_**Plugin** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  Нет.
#_
#_**Функции:**
#_
#_  Call
#_  Command
#_  Config
#_  Exist
#_  Load
#_  Menu
#_  Unload
#_
#_@@@
#_<lua> Links = {
#_  Call="65.html",
#_} </lua>
#_
#_
</article>
</node>
<node>
id=65
lv=3
dt=Text
nm=Call
ctime=3560706460
mtime=3580658521
<article>
#_... = Plugin.Call (PluginId, ...)
#_
#_**Параметры:**
#_  PluginId: string (GUID плагина в текстовом представлении)
#_  ...     : ноль или более дополнительных параметров
#_
#_**Возвращает:**
#_  ...     : ноль или более возвращаемых значений
#_
#_**Описание:**
#_  1. Параметры передаются плагину в соответствии с их Lua-типами:
#_       nil      -> FMVT_NIL
#_       boolean  -> FMVT_BOOLEAN
#_       number   -> FMVT_DOUBLE
#_       int64    -> FMVT_INTEGER (int64 - тип userdata, создаваемый библиотекой bit64)
#_       string   -> FMVT_STRING  (автоматически преобразуется из UTF-8 в UTF-16LE)
#_       {string} -> FMVT_BINARY  (для того, чтобы передать произвольный стринг без
#_                                 преобразования UTF-8 -> UTF16LE, его нужно передавать,
#_                                 помещённым в таблицу как элемент с ключом 1)
#_
#_  2. Если плагин не найден или вернул 0, макросу возвращается *false*.
#_     Если плагин вернул 1 или INVALID_HANDLE_VALUE, макросу возвращается *true*.
#_
#_  3. Величины, возвращаемые плагином через структуру *FarMacroCall*, передаются макросу
#_     следующим образом:
#_       FMVT_NIL     -> nil
#_       FMVT_BOOLEAN -> boolean
#_       FMVT_DOUBLE  -> number
#_       FMVT_INTEGER -> number, если "укладывается" в 53 бита, иначе int64
#_       FMVT_STRING  -> string (автоматически преобразуется из UTF-16LE в UTF-8)
#_       FMVT_BINARY  -> table (в таблице передаётся строка как элемент с ключом 1;
#_                              передаётся как есть, без преобразования)
#_       FMVT_ARRAY   -> table (массив элементов; в таблице установлено два поля:
#_                              ["type"] = "array", и
#_                              ["n"] = количество элементов массива)
#_
#_  4. При "асинхронном" вызове плагина, т.е. после вызова mmode(3,1), возвращается *true*,
#_     но только в случае, если вызов в действительности оказался "асинхронным", например,
#_     если плагин вывел диалог на экран. Иначе возвращается то, что вернул плагин.
#_
</article>
</node>
<node>
id=50
lv=2
dt=Text
nm=Viewer
ctime=3553252718
mtime=3553260812
<article>
#_**Viewer** - таблица со следующими полями:
#_
#_**Свойства:**
#_
#_  FileName:  string
#_  State:     number
#_
#_**Функции:**
#_
#_  Нет.
#_
#_
</article>
</node>
<node>
id=67
lv=1
dt=Text
nm=Формат макросов и обработчиков событий
ctime=3568746613
mtime=3580152284
<article>
#_@@@
#_На этапе загрузки макросов все файлы стационарных и клавиатурных макросов запускаются по очереди на исполнение. 
#_
</article>
</node>
<node>
id=75
lv=2
dt=Text
nm=Стационарные макросы
ctime=3580139016
mtime=3583262138
<article>
#_<markdown>
#_
#_* Стационарные макросы загружаются из Lua-файлов (расширение `*.lua`), находящихся в папке `%FARPROFILE%\Macros\scripts` и её подпапках.
#_
#_* Far Manager никогда не вносит никаких изменений в вышеуказанные папки. Набор и содержимое файлов в них определяется исключительно пользователем.
#_
#_* Один файл может содержать произвольное количество макросов.
#_
#_* При загрузке макросов первым всегда исполняется макрофайл
#_  `%FARPROFILE%\Macros\scripts\_macroinit.lua`, если такой файл существует. Порядок исполнения прочих макрофайлов не определён.
#_
#_* Загрузка макроса происходит при вызове глобальной функции `Macro`, которой передаётся один аргумент - таблица с параметрами макроса.
#_
#_```
#_  Macro {
#_    area        = "Shell Info Tree";                         -- string
#_    key         = "CtrlF11 ShiftHome";                       -- string
#_    description = "Macro example";                           -- string (опциональное поле)
#_    flags       = "NoPluginPanels EmptyCommandLine";         -- string (опциональное поле)
#_    filemask    = "*.txt,*.cpp";                             -- string (опциональное поле)
#_    priority    = 50;                                        -- number (опциональное поле)
#_    condition   = function(key) return Far.Height>30 end;    -- function (опциональное поле)
#_    action      = function() msgbox("","Macro example") end; -- function
#_  }
#_```
#_
#_1. Поле `area` может содержать имена одной или нескольких областей, разделённых пробелами.
#_
#_1. Поле `key` может содержать имена одного или нескольких ключей, разделённых пробелами.<br>
#_   Ключи могут содержать модификаторы: `Ctrl,LCtrl,RCtrl,Alt,RAlt,LAlt,Shift`.<br>
#_   `Ctrl` означает "любой из `LCtrl,RCtrl`", аналогично для `Alt`.
#_   Порядок указания модификаторов - произвольный.<br><br>
#_   Альтернативно, поле `key` может быть задано как регулярное выражение, обрамлённое
#_   слешами (`/`).
#_   * В этом случае `/Ctrl/` не сработает при нажатии `RCtrl`, надо явно обозначать
#_     `/[LR]Ctrl/` и т.п.
#_   * Также в этом случае необходимо соблюдать порядок в последовательности
#_     `Ctrl`,`Alt`,`Shift`, например `/[LR]Alt[LR]CtrlF1/` никогда не сработает.<br><br>
#_
#_1. Опциональное поле `priority` (приоритет) - число от 0 до 100.<br>
#_   Значение по умолчанию = 50 (для области `Common` = 40).<br>
#_   Макросы, добавляемые посредством `MCTL_ADDMACRO`, имеют приоритет = 50.
#_
#_1. Опциональное поле `filemask` - строка.<br>
#_   Применимо только для областей `Editor` и `Viewer`. Обрабатывается по правилам,
#_   аналогичным тем, которые Фар применяет для масок файлов при поиске из панелей и т.д.
#_   Если имя файла, открытого в редакторе или просмотрщике, не соответствует заданной маске,
#_   макрос выполняться не будет.
#_
#_1. Опциональное поле `condition` - функция.
#_   * Вызывается с одним аргументом: имя нажатого ключа.
#_     Для автостартующих макросов - вызывается без аргументов.
#_   * Eсли возвращает `false`/`nil`/ничего, то макрос не исполняется.
#_   * Если возвращает число, то это число используется вместо `priority`.
#_   * При других значениях возврата (например, `true`) используется `priority`.<br><br>
#_
#_1. Поле `action` - функция.<br>
#_   Если макрос успешно прошёл все предварительные проверки (область действия, флаги,
#_   маска файла, приоритет), то вызывается функция `action`.
#_
#_1. Допустимо более одного макроса на сочетание (`key`,`area`). В этом случае выполняется макрос с наибольшим приоритетом. Если есть более одного макроса с одинаковым наибольшим приоритетом - выводится меню выбора макроса.<br>
#_   Автостартующие макросы выполняются все, независимо от приоритета. Очерёдность их исполнения не определена.
#_
</article>
</node>
<node>
id=76
lv=2
dt=Text
nm=Клавиатурные макросы
ctime=3580139029
mtime=3580139289
<article>
#_<markdown>
#_
#_* Клавиатурные макросы обычно используются для быстрой записи и воспроизведения
#_  последовательности нажатий клавиш клавиатуры. Они имеют меньше возможностей,
#_  чем стационарные макросы, и для использования на постоянной основе стационарные
#_  макросы предпочтительнее.
#_
#_* Клавиатурные макросы загружаются из Lua-файлов (расширение `*.lua`), находящихся
#_  в папке `%FARPROFILE%\Macros\internal`.
#_
#_* Far Manager самостоятельно создаёт, модифицирует и удаляет файлы в данной папке
#_  в соответствии с выполняемыми над макросами операциями. Не рекомендуется редактировать
#_  эти файлы вручную, за исключением удаления.
#_
#_* Изменения в клавиатурных макросах становятся постоянными либо при выполнении операции
#_  `MacroControl(MCTL_SAVEALL)`, либо автоматически (при включенной опции "Auto save setup").
#_
#_* Поле "area" может содержать только одну область действия.
#_
#_* Поле "key" может содержать имя только одного ключа.<br>
#_  В ключах применяются только модификаторы `Ctrl,Alt,Shift` и не применяются
#_  модификаторы `LCtrl,RCtrl,LAlt,RAlt`. Регулярные выражения не поддерживаются.
#_
#_* Не допустимо более одного макроса на сочетание (`key`,`area`).
#_
#_* Клавиатурные макросы имеют более высокий приоритет, чем все прочие макросы.
#_  Это сделано для того, чтобы не надо было заниматься разрешением конфликтов
#_  при временном создании клавиатурных макросов (типичный сценарий их использования).
#_
</article>
</node>
<node>
id=78
lv=2
dt=Text
nm=Обработчики событий
ctime=3580139337
mtime=3583395200
<article>
#_<markdown>
#_
#_Как и [стационарные макросы][1], обработчики событий загружаются из Lua-файлов (расширение `*.lua`), находящихся в папке `%FARPROFILE%\Macros\scripts` и её подпапках. Каждый Lua-файл может содержать вместе и макросы, и обработчики событий.
#_
#_Загрузка обработчика происходит при вызове глобальной функции `Event`, которой передаётся один аргумент - таблица с параметрами обработчика.
#_
#_```
#_Event {
#_  group       = "EditorEvent";         -- string
#_  description = "Event example";       -- string (опциональное поле)
#_  filemask    = "*.txt,*.cpp";         -- string (опциональное поле)
#_  priority    = 50;                    -- number (опциональное поле)
#_  condition   = function() ...... end; -- function (опциональное поле)
#_  action      = function() ...... end; -- function
#_}
#_```
#_
#_Поле `group` может иметь одно из следующих значений:<br>
#_`"DialogEvent", "EditorEvent", "EditorInput", "ExitFAR", "ViewerEvent"`.<br>
#_Данные имена являются производными от имён соответствующих функций, экспортируемых плагином, например:<br>
#_        export.ProcessDialogEvent -> DialogEvent
#_Функции `condition` и `action` обработчика вызываются с теми же параметрами, с которыми вызывается соответствующая экспортируемая функция (см. мануал LuaFAR).
#_
#_При наличии нескольких обработчиков одного и того же события (т.е. обработчиков с одинаковым полем `group`), эти обработчики будут вызваны по очереди: обработчик с более высоким приоритетом вызывается раньше. Приоритет определяется динамически с учётом функции `condition`, если таковая имеется, как и для макросов.
#_
#_Событие `"ExitFAR"` вызывается в следующих случаях: (a) выход из Far Manager,
#_(b) выгрузка плагина LuaMacro, \(c) выгрузка либо перезагрузка макросов.
#_
#_[1]: 75.html
#_
</article>
</node>
<node>
id=77
lv=2
dt=Text
nm=Lua-модули
ctime=3580139041
mtime=3580219485
<article>
#_<markdown>
#_
#_Lua-модули могут быть помещены в папку `%FARPROFILE%\Macros\modules` и её подпапки, так как
#_
#_`%FARPROFILE%\Macros\modules\?.lua;%FARPROFILE%\Macros\modules\?\init.lua;`
#_
#_автоматически добавляется в `package.path`.
#_
</article>
</node>
<node>
id=7
lv=1
dt=Text
nm=Плагин Luamacro
ctime=3551991405
mtime=3582019867
<article>
#_<markdown>
#_Данный плагин необходим для работы макросов, поэтому должен быть установлен.
#_То же касается и рантайма (файлы *lua5.1.dll* и *luafar3.dll*), необходимого
#_для работы плагина.
#_
#_### Работа с командной строки (префикс LM)
#_        lm: load
#_        lm: save
#_        lm: post  <sequence> | @<filename> [<params>]
#_        lm: check <sequence> | @<filename> [<params>]
#_        lm: unload
#_
#_Эти операции аналогичны операциям `macro:` плагина `FarCmds`, со следующими отличиями:
#_
#_1. Имя файла должно указываться сразу после символа `@`; символ `<` не поддерживается.<br>
#_   Если нужно передать скрипту параметры, их следует указать после имени файла через пробел.
#_   Параметры являются списком Lua-выражений, разделённых запятыми.
#_1. `lm:unload` - выгружает все макросы, за исключением созданных операцией `MCTL_ADDMACRO`.
#_
#_@@@
#_
</article>
</node>
<node>
id=5
lv=1
dt=Text
nm=Разное
ctime=3551990771
mtime=3551990771
<article>
</article>
</node>
<node>
id=2
lv=2
dt=Text
nm=Макросы, начинающиеся с @
ctime=3551901528
mtime=3578456909
<article>
#_<markdown>
#_Если макропоследовательность начинается с символа `@`, то последующая её часть интерпретируется как имя файла, содержащего скрипт.
#_
#_Переменные окружения расширяются.
#_
#_Такие макросы легче отлаживать и модифицировать, так как не требуется их перезагрузка.
#_
#_**Пример 1:** `lm:post @%FARHOME%\test\test.lua`
#_
#_**Пример 2:** [запуск скрипта из редактора][example].
#_
#_[example]: 74.html
#_
</article>
</node>
<node>
id=14
lv=2
dt=Text
nm=Переменные
ctime=3552028510
mtime=3564676943
<article>
#_<markdown>
#_### Окружение
#_Макросы, загружаемые из одного файла, имеют общее окружение (environment).
#_Переменные, объявляемые без ключевого слова *local*, принадлежат этому окружению.
#_
#_      Пример: var = 15
#_
#_Переменные окружения макрофайла сохраняют свои значения между вызовами макросов. Их значения сбрасываются в исходные при выполнении любой операции загрузки макросов: старт Far Manager, `macro:load`, `lm:load`, `far.MacroLoadAll`, `MacroControl(MCTL_LOADALL)`.
#_
#_### Глобальные переменные
#_Для установки глобальных переменных, значения которых будут сохраняться в течение всей сессии Far Manager и будут доступны всем скриптам, нужно использовать таблицу `_G`.
#_
#_      Пример: _G.var = 15
#_
#_Глобальные переменные не меняют своего значения даже при операциях перезагрузки макросов, за исключением рестарта Far Manager или перезагрузки плагина LuaMacro.
#_
#_При чтении несуществующей переменной окружения, прочтётся одноимённая глобальная переменная (наследование в некотором смысле).
#_
#_      Пример:
#_        var = 5
#_        _G.var = 10
#_        far.Message(var) --> 5
#_        var = nil
#_        far.Message(var) --> 10
#_
#_### Upvalues
#_Локальные переменные, доступные из функций одного или нескольких макросов (upvalues), являются общими для этих функций и сохраняют свои значения между вызовами макросов. Их значения сбрасываются в исходные при выполнении любой операции загрузки макросов.
#_
#_      Пример:
#_        local var = 15
#_        function inc_var() var = var+1 end
#_        function dec_var() var = var-1 end
#_
</article>
</node>
<node>
id=62
lv=2
dt=Text
nm=Ограничения в использовании некоторых функций
ctime=3557323094
mtime=3572419862
<article>
#_<markdown>
#_Следующие функции имеют особенности реализации, которые накладывают определённые ограничения на их использование в макросах:
#_
#_* `exit`
#_* [`mf.usermenu`][usermenu] (в "асинхронном" режиме вызова)
#_* `Keys`
#_* `Plugin.Call`
#_* `Plugin.Command`
#_* `Plugin.Config`
#_* `Plugin.Menu`
#_* `print`
#_* `printf`
#_
#_1. Если макрос создаёт корутины с помощью `coroutine.wrap(f)`, то вышеперечисленные функции не будут работать, будучи вызванными из тела функции `f`.<br>
#_Данного ограничения нет, если корутины создаются с помощью `coroutine.create(f)`.
#_
#_1. Вышеперечисленные функции, будучи вызванными прямо или косвенно посредством функции `pcall`, приведут к немедленному возврату `pcall` с результатом `false`.<br>
#_Данного ограничения нет при использовании LuaJIT 2.0.
#_
#_1. Вышеперечисленные функции не будут работать, будучи вызванными из диалоговой процедуры. Однако их можно вызывать из диалоговой процедуры посредством `far.MacroPost`.
#_
#_1. Вышеперечисленные функции не будут работать, будучи вызванными из функции *condition* макроса.
#_
#_[usermenu]: 69.html
</article>
</node>
<node>
id=63
lv=2
dt=Text
nm=Интроспекция
ctime=3558901787
mtime=3558902462
<article>
#_<markdown>
#_Содержимое глобальных таблиц API макроязыка можно просмотреть с помощью
#_функции `pairs`, отдельно для функций и "свойств" таблицы.
#_
#_На примере таблицы `Editor`:
#_
#_        for k,v in pairs(Editor) do .... end -- для функций
#_
#_        for k,v in pairs(Editor.properties) do .... end -- для свойств
#_
</article>
</node>
<node>
id=64
lv=2
dt=Text
nm=unicode.utf8.cfind
ctime=3559410790
mtime=3559414983
<article>
#_<markdown>
#_
#_Эта функция аналогична `unicode.utf8.find`, кроме того, что она принимает входное
#_смещение и возвращает выходные смещения в **символах**, а не в **байтах**.
#_(Исключением являются "position captures", которые всё же возвращаются в байтах).
#_
</article>
</node>
<node>
id=73
lv=2
dt=Text
nm=package.nounload
ctime=3578403115
mtime=3578408569
<article>
#_<markdown>
#_
#_`package.nounload` - это таблица, ключи которой являются именами модулей, не удаляемых из `package.loaded` при выгрузке или перезагрузке макросов (операции `MCTL_LOADALL`, `lm:load`, `lm:unload`).
#_
#_* Таблица создаётся автоматически плагином LuaMacro.
#_* Обычно в эту таблицу заносятся имена модулей, использующих LuaJIT FFI и вызывающих `ffi.cdef`.
#_
#_Например, если исполнить
#_
#_        package.nounload.mylib = true
#_
#_то модуль `mylib` не будет удалён их `package.loaded` при операциях выгрузки или перезагрузки 
#_макросов.
#_
#_
</article>
</node>
<node>
id=29
lv=1
dt=Text
nm=Примеры
ctime=3552222267
mtime=3552222267
<article>
</article>
</node>
<node>
id=39
lv=2
dt=Text
nm=Выделить слово под курсором
ctime=3553195063
mtime=3568784026
<article>
#_<markdown>
#_```
#_Macro {
#_  description="Выделить/снять выделение слова под курсором";
#_  area="Editor"; key="CtrlM";
#_  action=function()
#_    Keys"RCtrl9 CtrlRight CtrlLeft"
#_    Keys(Object.Selected and "CtrlU" or "CtrlShiftRight")
#_    Keys"Ctrl9"
#_  end;
#_}
#_```
#_
</article>
</node>
<node>
id=40
lv=2
dt=Text
nm=Переход в меню выбора дисков
ctime=3553195940
mtime=3568784018
<article>
#_<markdown>
#_```
#_-- Переход в меню выбора дисков на противоположной панели,
#_-- включение видимости панели, в которой будет происходить
#_-- смена диска, если её не было.
#_Macro {
#_  description="Переход в меню выбора дисков на противоположной панели";
#_  area="Disks"; key="CtrlM";
#_  action=function()
#_    Keys"Esc"
#_    if not PPanel.Visible then
#_      Keys(APanel.Left and "CtrlF2" or "CtrlF1")
#_    end
#_    Keys"Tab F9 Enter End Enter"
#_  end;
#_}
#_```
#_
</article>
</node>
<node>
id=30
lv=2
dt=Text
nm=Выделить файлы новее текущего
ctime=3552222560
mtime=3568784169
<article>
#_<markdown>
#_```
#_-- Выделить в активной панели все файлы/папки новее текущего,
#_-- используя API плагинов (LuaFAR).
#_Macro {
#_  description="Выделить в активной панели все файлы/папки новее текущего";
#_  area="Shell"; key="CtrlM";
#_  action=function()
#_    local info = panel.GetPanelInfo(nil,1)
#_    local curItem = panel.GetCurrentPanelItem(nil,1)
#_    for i=1,info.ItemsNumber do
#_      local item = panel.GetPanelItem(nil,1,i)
#_      if item.LastWriteTime > curItem.LastWriteTime then
#_        panel.SetSelection(nil,1,i,true)
#_      end
#_    end
#_    panel.RedrawPanel(nil,1)
#_  end;
#_}
#_```
#_
#_```
#_-- Выделить в активной панели все файлы/папки новее текущего,
#_-- используя API макросов (LuaFAR + LuaMacro).
#_Macro {
#_  description="Выделить в активной панели все файлы/папки новее текущего";
#_  area="Shell"; key="CtrlM";
#_  action=function()
#_    d = Panel.Item(0,0,17)
#_    for i=1,APanel.ItemCount do
#_      if Panel.Item(0,i,17) > d then
#_        Panel.Select(0,1,1,i)
#_      end
#_    end
#_  end;
#_}
#_```
#_
</article>
</node>
<node>
id=41
lv=2
dt=Text
nm=Cоздание папки с именем = текущей дате
ctime=3553206604
mtime=3578456092
<article>
#_<markdown>
#_```
#_Macro {
#_  description="создание папки с именем = текущей дате";
#_  area="Shell"; key="CtrlShiftF7"; flags="NoPluginPanels";
#_  action=function()
#_    folder = mf.date("%d.%m0.%Y")
#_    if Panel.FExist(0,folder)==0 then
#_      Keys"F7 CtrlY"
#_      print(folder)
#_      Keys"Enter"
#_    end
#_  end;
#_}
#_```
#_
</article>
</node>
<node>
id=74
lv=2
dt=Text
nm=Запуск скрипта из редактора
ctime=3578455778
mtime=3578456003
<article>
#_<markdown>
#_```
#_-- Данный макрос сначала сохраняет содержимое редактора (если оно не было сохранено),
#_-- затем исполняет редактируемый файл как Lua-скрипт.
#_Macro {
#_  description="Save and run script from editor";
#_  area="Editor"; key="CtrlF10";
#_  action=function()
#_    for k=1,2 do
#_      local info=editor.GetInfo()
#_      if bit64.band(info.CurState, far.Flags.ECSTATE_SAVED)~=0 then
#_        far.MacroPost("@"..info.FileName); break
#_      end
#_      if k==1 then editor.SaveFile(); end
#_    end
#_  end;
#_}
#_```
#_
</article>
</node>
<node>
id=70
lv=1
dt=Text
nm=Articles
ctime=3576179916
mtime=3578043315
<article>
</article>
</node>
<node>
id=71
lv=2
dt=Text
nm=FAR Manager. Macros and whatnot.
ctime=3578043305
mtime=3578065765
<article>
#_<markdown>
#_<font face="Tahoma">
#_
#_By **Gleb Varenov** ("Acerbic") » Tue 23 Apr, 2013 22:53<br>
#_[Revision 1.1][article on forum]
#_
#_*Gather round, boys and girls, for I am about to tell you a story.*
#_
#_## Macro in your FAR Manager? It's more likely than you think.
#_
#_The "macro" term is used loosely in Far to describe a broad range of user-made modifications of the application's behavior. For the sake of simplicity, let me divide them into several use cases:
#_
#_1. Assigning <font color="red">hotkeys</font> / remapping key bindings.
#_This is the simplest. You want one custom key (or combination with Ctrl, Shift, Alt modifiers) do what another key (combination) already does. It is one for one replacement.
#_
#_2. Your typical <font color="red">macro</font>. Press one key to emulate a sequence of many keys.
#_Its not much different from just a hot key. You press a key - it is treated as if you pressed some fixed predefined string of keys.
#_
#_3. <font color="red">Script</font>.
#_Now this is interesting. Script involves logic and decision making, not just some fixed reaction. A script has means to analyze current situation and affect Far Manager in non-trivial ways. Requires programming skills to create, but luckily the are many scripts already written and you may find one just fitting your needs.
#_
#_4. <font color="red">Plugin</font>.
#_Well, this is a moot point. With the course Far development is following now the gap between a complex script and a full fledged plugin is closing rapidly. As of right now, a script has most of functional capabilities a plugin has, it has access to both macro API and plugin API, in the latest builds a macro script can be started by an event, not just by a key pressed and so forth...
#_
#_## History and identification of obsolete.
#_
#_FAR Manager has traveled a long way from its early versions and so did its macro capabilities. In Far1 and Far2 the configuration was stored in Windows registry, including macros. In Far3 configuration was moved to SQLite database files located in user's profile folder. But later it was decided that it would be better to allow users simpler access to macros and they were moved from a database to individual files (still inside user's profile folder). Also, parallel to moving macro definitions to external files, the macro language was changed to LUA.
#_
#_In addition to that, there is a very popular plugin called "MacroLib". It provides extended macro features on top of built-in system. It used to overlay old macro language, but then switched to LUA as well. It always stored macros in external files.
#_
#_So, what to look out for to spot outdated manuals / macro recipes?
#_
#_1. \*.reg files. Partial and full configurations were distributed as reg import files in times of Far1 and Far2. That included macros. No \*.reg files are used by Far3 plugins or Far3 itself, but some old (ANSI) Far1 plugins can still use them. Any macros contained in them won't work in Far3.
#_
#_2. \*.farconfig files. Those are XML text files containing configurations for Far3. They are still used for other parts of configuration (coloring schemes and such) but not for macros anymore.
#_
#_3. Old macro language. It contained keywords like "$IF" "$ELSE" - denoted by dollar sign.
#_
#_4. Old MacroLib files \*.fml - new MacroLib macro files use "fmlua" extension.
#_
#_It is important to note that internal help in Far (called by "F1") is massively lagging behind development - hence this article.
#_
#_## What now?
#_
#_At present, by means of storage macros fall in three groups.
#_
#_1. Files of the built-in macro system. \*.lua
#_Located in <font color="blue">%FARPROFILE%/Macros/internal</font> and <font color="blue">%FARPROFILE%/Macros/scripts</font>
#_
#_2. MacroLib files \*.fmlua.
#_By default are located within plugin's folder, but it can be configured to read macros from any user defined path (or several).
#_
#_3. Other macro processing plugins. "Lua4Editor", for example. I don't know much about these, you are on your own here, folks.
#_
#_Important warning! There are plugins written in LUA. These are something different from macros. They are legit plugins with all the things a "usual" plugin has (like being listed in plugins' menu "F11"). Except they are written in LUA and distributed as source files. They should not confuse you as they lie in their folders in <font color="blue">%FARHOME%/Plugins</font>
#_
#_## Conversion.
#_
#_It is best to rewrite your macros in LUA from scratch. If they are few and simple, it won't take much effort. If they are complex, conversion is likely to fail to do it automatically. But if you are still interested in doing things hard way, there are few tools to help you. They were meant as quick fixes for transition period and aren't supported anymore, probably.
#_
#_1. Far1, Far2 -> Far 3 [2x3 perl converter][perl converter]
#_This tool is used to convert old configuration from registry to database. This includes macros.
#_The result will be a bunch of XML files containing far configurations and macros in the old language.
#_
#_2. Translation from old language to the new one is done by [Macro2Lua Converter][m2l converter] plugin. The readme is in Russian, but here is an excerpt regarding main usage via command line
#_><span style="background-color: #CCCCCC;">`M2L: convert <input file> <output file> [<syntax>]`</span><br>
#_where `<syntax>` is optional input format specifier and is one of following:
#_`xml_file`, `xml_macros`, `xml_keymacros`, `xml_macro`, `fml_file`, `fml_macro`, `chunk`, `expression`. General file format is the part before underscore, the specific section of a file is the part after underscore. "`chunk`" and "`expression`" are some kind of raw macro pieces of texts.
#_The result should be a XML file (`<farconfig>...</farconfig>`) with macros translated to LUA inside of it or a MacroLib fmlua file if original was \*.fml and corresponding syntax was specified.
#_
#_3. Far3 2927-3000 -> Far3 3001+
#_Now you need an older version of Far3 (pre3001). You import your macros to Far per usual command, then use a script provided in the following forum thread:<br>
#_[Macros have been moved from macros.db to files][move to files]
#_
#_## Managing confusion.
#_
#_While all macros are written in LUA, file contents are not interchangeable as of right now. It means that you can't rename X.fmlua to X.lua, move it to <font color="blue">%FARPROFILE%/Macros/scripts</font> and expect it to work. Likewise you can't just move files from <font color="blue">/internal</font> to <font color="blue">/scripts</font>.
#_
#_Luckily, with few rules I am about to explain, you won't get lost in all of the LUA files lying around.
#_
#_1. Don't touch your internals!
#_Files in <font color="blue">%FARPROFILE%/Macros/internal</font> are to be manipulated (created/edited/deleted) by FAR Manager itself. And while it is possible to edit them manually, better to leave them alone. Unless you really know what are you doing. Or just feeling adventurous.
#_
#_2. MacroLib files are always named \*.fmlua, so you can never confuse them with native script files, even if you configured the MacroLib so they are located in the same directory.
#_
#_3. User-made native script files are located in <font color="blue">%FARPROFILE%/Macros/scripts</font> and are named \*.lua. They are read at Far launch, but you can make Far to re-read the folder via command line (more on that later).
#_
#_So, only (2) and (3) are in user's management and they are different in names, location and internal structure.
#_
#_But there are similarities too.
#_
#_1. Both MacroLib and native macros have a concept of "Area of execution" - basically, a broad condition limiting macro effect. Typical are "Editor" - when editor is open, "Shell" - when file panels are in focus, etc...
#_
#_2. In addition to general area, some more conditions might be specified for activation of a macro. Like passive panel being visible, command line not being empty and similar. These conditions/flags are legacy carried over from times when macro language was primitive and things like that were hard to check in script itself. Alternatives are being developed (like custom function conditionals in native scripts) but there is no sign that old flags will be abandoned yet.
#_
#_3. And finally, there are two flags that control execution of the macro itself. One is to disable/enable intermediate visual output during macro execution (reduces flicker of menus and dialogs being open/closed, for example), another is to control if plugins can intercept keyboard events generated by macro. No other macro can intercept current macro while it is executing - so you don't have to worry about nasty macro interferences.
#_
#_## Out of the box.
#_
#_In the beginning of time the macro language was ugly and everyone was sad. And few of the developers raised their voices: "Look! There in the great outside lies shiny LUA. Let us take it for ourselves, let us bind it to our manager and then we won't be suffering dollar-signed keywords no more." And so they did. And night turned day, and day turned night, and the Moon died and was born again as they tinkered and meddled and compiled and debugged. Seasons passed by, but finally, the day has come and their labor was over.
#_And they stood proud among men and shouted: "Behold this LuaMacro plugin! We can rework our ugly macros into LUA, we have the technology now. But wait! There's more: we can write plugins in LUA as well, if we desire so." And everyone rejoiced.
#_And gathered developers of Far and saw what their brethren did, and saw that it was good. So good in fact, they put the new plugin in the core package and abandoned their old ways of macros.
#_
#_So, native macro capabilities are provided by LuaMacro plugin, which is distributed with Far itself as part of its core package. The plugin has no configuration dialog, but has a list of commands to manipulate it:
#_
#_* <span style="background-color: #CCCCCC;">`lm: unload`</span> - Far forgets all macros. They are still on disk and can be loaded back with next command.
#_
#_* <span style="background-color: #CCCCCC;">`lm: load`</span> - makes Far discard all macros and then re-read them from directories anew.
#_
#_* <span style="background-color: #CCCCCC;">`lm: post <sequence>|@<filename>`</span> - executes a macro code immediately. Either a "raw" piece of code typed in command line, or same raw code saved in a file. File name is prefixed with "@" symbol.
#_
#_* <span style="background-color: #CCCCCC;">`lm: check <sequence>|@<filename>`</span> - same as above. Except the macro is not executed but checked for syntax errors.
#_
#_* <span style="background-color: #CCCCCC;">`lm: save`</span> - saves changes made to "internal" macro files. Useful if you have "Auto save setup" option turned off.
#_
#_When "load" and "unload" operations are concerned, only native macros are affected. I.e. those *.lua that are located in <font color="blue">/internal/</font> and <font color="blue">/scripts/</font>. MacroLib macros are not touched. List of all currently loaded native macros is available in Far built-in help "F1". That part of help is not translated to English yet, and its not very convenient in operation anyway. Check [this][farman macro] macro out though.
#_
#_Note. "lm:" commands are similar to ones provided by FarCommands plugin via "macro:" and "far:macro " prefixes. There was a difference in that FarCommands used "<" symbol to specify filename, but now it supports both "<" and "@" for this.
#_
#_It is time now to explain why some macros are put in <font color="blue">/internal/</font> and others in <font color="blue">/scripts/</font>. Its fairly simple - "internal" is a codename for "recorded" and all the recoded macros go there. More on recorded macros is in the "<font color="red">Hotkeys / Macro use case</font>" chapter.
#_User-made macros are to be placed in <font color="blue">/scripts/</font>. Sadly, there's no comprehensible manual on how to write them. One is reduced to scavenging for bits and pieces of knowledge by perusing Far's changelog and dissecting macros written by others ([SimSU macro pack][SimSU] for example, topic in Russian forum: [http://forum.farmanager.com/viewtopic.php?f=15&t=7075] [SimSU topic]). Here is a script for the Editor that pastes a macro template on "Ctrl+F11" by Shmuel: [InsertMacro.lua.7z][InsertMacro]
#_
#_## MacroLib.
#_
#_This is what all the cool kids use. MacroLib is a plugin that provides somewhat extended functionality to macros. It is built on top of native macro system, so 99% of the code working for "regular" macro will work for MacroLib as well.
#_Project's main page: [http://code.google.com/p/far-plugins/wiki/MacroLib] [macrolib main], download page: [http://code.google.com/p/far-plugins/downloads/list?q=MacroLib] [macrolib dload], documentation (Russian): [http://code.google.com/p/far-plugins/wiki/FML] [macrolib docs].
#_MacroLib files are named *.fmlua and are located in one or several directories designated by user in configuration dialog. The dialog allows you to update macros from disk and shows you a very neat list of all macros currently loaded with ability to sort, filter, run a macro from the list.
#_
#_MacroLib used to have many advantages over built-in system, but nowadays Far has caught up for the most part and is ahead in some experimental things (like events). However, there are two things \*.fmlua scripts have over \*.lua ones.
#_
#_1. You can use modifiers to your assigned hotkeys, such as "Hold" (macro is invoked after the key was held for a certain period of time), "Double"(on double click or double key tap), "Release" (macro is called on key being released, rather than being pressed).
#_2. You frame your macro code in double curly brackets for extra swag {{ }}.
#_
#_## Hotkey / Macro use case.
#_
#_Can't get used to saving edited file by "F2"? Too lazy to run through menus every time you want to view your current Folder Shortcuts? Then this chapter is for YOU. This chapter covers a very simple usage of Far macros - redefining hotkeys for existing actions and creating hotkeys for actions that don't have them by default.
#_The easiest way to do said things is by using "Recorded Macro" feature. The Far Manager has an ability to record your actions (keyboard events) and assign them to a specific key, pressing which will replay your actions. This function is in there from Far1 and is explained in "F1" Help, but I will rehash it for you anyway.
#_You start recording by pressing "Ctrl+." (Control key plus dot key) or "CtrlShift+.", a little red "R" letter appears in the top-left corner and your following key presses will be recorded. You continue to use Far as usual, doing things you want to be put in the macro, or just pressing one key you want to be remapped. Then you finish recording by pressing "Ctrl+." or "CtrlShift+." again. Then you will be asked for a key to which this macro will be assigned, you can select one from a drop-down list with a mouse or just press the desired combination, then "Enter". At this moment an optional dialog might appear to configure additional parameters of you macro.
#_
#_So,
#_
#_1. "Ctrl+." or "CtrlShift+."
#_2. Do stuff on record.
#_3. "Ctrl+." or "CtrlShift+."
#_4. Select a desired key to assign to.
#_5. (optional) Configuration dialog.
#_
#_If you finish recording with "CtrlShift+." on step 3 you will be shown a dialog on step 5. Otherwise you won't be. To know more about this dialog, press "F1" while in there, its covered in the Help.
#_Starting the recording with "CtrlShift+." puts a "NoSendKeysToPlugins" flag on your macro, which means that during macro playback plugins won't be able to react to keyboard events generated by this macro - it forces plugins to ignore this macro in that regard.
#_
#_If you made a mistake in your macro during recording you may interrupt the recording by usual "Ctrl+." and then hit "Esc" when asked about desired key.
#_If you select a key that is already taken by a macro, you will be asked if you want to overwrite previous macro. This means you cannot have two recorded macros on the same key in the same area of execution. You can, however, have one for each area (one in Editor, one in Viewer, etc.)
#_If you need to delete a macro you previously recorded, you create an empty macro for the key you want to free: "Ctrl+.", "Ctrl+.", the key. Then select "yes" to confirm deletion.
#_
#_If you have "F9"->"Options"->"System Settings"->"Auto save setup" option turned on, then every change to your recorded macros (creation, modification, deletion) will be immediately saved to files. Otherwise you can use <span style="background-color: #CCCCCC;">`lm: save`</span> command to save your recorded macros or press "Shift+F9" to save full setup.
#_If you want to know what macros are already recorded, you can navigate to <font color="blue">%FARPROFILE%/Macros/internal</font>. It is possible delete macros in there, just don't forget to use <span style="background-color: #CCCCCC;">`lm: load`</span> command to update, or restart Far.
#_
#_Example: lets bind a hotkey to "File associations" menu.
#_
#_0. (preparation) Make sure you are in the Shell area of Far, its where two panels with files and folders are.
#_1. Press "Ctrl+." and make sure the red "R" letter appeared.
#_2. Press "F9" to move input focus to Far's menu (usually is the top line of the window), then "c" for commands, then "a". Now, if done right the "File associations" menu is on screen.
#_3. Press "Ctrl+."again, a little "Define macro" box should pop up. Press "Ctrl+Shift+a" and confirm that corresponding key code appeared in the box ("CtrlShiftA").
#_4. Press "Enter" and enjoy a new quality of life improvement you just created for yourself. Now every time you press "Ctrl+Shift+a" combo in Far shell, the menu will instantly appear.
#_
#_## Script use case.
#_"Script" is a program that runs within/by other program (as opposed to one run by CPU/OS). Scripts in Far evolved from macros to a point when macros themselves are considered primitive cases of scripting. Being programs, scripts require "Programming / Coding" skill to be created, therefore, if you intend to use Far to its fullest potential you might want to invest few skill points in it on your next level up. Alternatively, you can utilize macros written by someone else - just copy the files in appropriate folders.
#_As mentioned before, Far uses LUA language for scripting. From within the script you have access to
#_
#_1. Far (plugin) API - functions of Far that are available to plugins.
#_
#_2. Far macro API - some specific functions that were available in old language. These overlap "Plugin API" to some extend and considered legacy API. Better use "Plugin API" where possible.
#_
#_3. Custom functions exported by plugins - some plugins export their functions to be called from macro. Those depend on plugin being installed and loaded, of course.
#_
#_4. LUA libraries - native to LUA (see language manual) plus few libraries additionally shipped with LuaFar ("bit64", "win" - gate to Win API, Selene Unicode)
#_
#_5. Far UI - you can control Far simply by issuing keyboard/mouse commands to it. Why bother finding a function that will open Editor for file under cursor when you can just send "F4" to Far?
#_
#_Your main source of information about Far APIs is in <font color="blue">%FARHOME%\Encyclopedia</font> files. Lets look at them.
#_
#_* "FarEncyclopedia.ru.chm" - includes (1) and (2), in Russian. Macro API is outdated (pre-LUA). There's an online version too: [http://api.farmanager.com/ru/] [encyclopedia]
#_
#_* "luafar_manual.chm" - originally a LuaFar plugin manual (writing plugins in LUA), but we can use it in scripts too. Covers (1) in LUA in English. Very spartan - most of the functions have no textual descriptions, only input parameters and result values (implies ability to read "FarEncyclopedia.ru.chm"). For the most part it is not a problem though, functions' names are self-descriptive.
#_
#_* "macroapi_manual.chm" - mapping of (2) to LUA. Again, almost no descriptions.
#_
#_Damn, its kinda depressing, ain't it? Luckily for you, I have a magical artifact that will allow you to understand Russian: [abracadabra][abracadabra]. Paste a link to Russian website or text fragment and hit "Enter".
#_And Acerbic saves the day once again! You are welcome.
#_
#_To sum it up: you will use "luafar_manual.chm" in conjunction with [translated online encyclopedia][translated] for Far plugin API reference and "macroapi_manual.chm" in conjunction with [this link][this link] for Macro API reference.
#_I found this script very helpful: [lua_explorer][lua explorer]. It allows you to browse Lua tables/values/functions soup available to LUA script. [Thread][thread] on the forum.
#_
#_## Native or MacroLib?
#_
#_MacroLib.
#_
#_## Sample script.
#_
#_Here's a little demonstration of what you can do in MacroLib: "RCtrl Folder shortcuts.fmlua"
#_
#_```
#_;;
#_;; Folder shortcuts menu
#_;; RCtrl single pressing or holding will pop-up the shortcuts menu. Press RCtrl again (or Esc) to close it.
#_;; RCtrl1-0 will go to set shortcut
#_;;
#_ 
#_const FolderShortcutsId = "4CD742BC-295F-4AFA-A158-7AA05A16BEA1"
#_ 
#_macro
#_area="Shell"
#_description="Folder shortcuts popup"
#_key="RCtrl:Hold RCtrl:Release"  ;; call on holding LCtrl or single press of the button (Need to specify Release after Hold bc of a bug)
#_EatOnRun=0 ;; allows RCtrl:Release in Menu area after RCtrl:Hold was caught
#_{{ 
#_    Keys("F9 c d");
#_}}
#_ 
#_macro
#_area="Menu"
#_description="Folder shortcuts: RCtrl+digit"
#_key="/RCtrl\d/"
#_{{
#_    if (Menu.Id == #%FolderShortcutsId) then
#_        Keys(regex.match(akey(1),"RCtrl(\\d)?")) -- double escaping \\ because of LUA strings parsing
#_    end;
#_}}
#_ 
#_macro
#_area="Menu"
#_description="Folder shortcuts: pass RCtrl+not_digit through"
#_key="/RCtrl(?!\d$).+/"      ;; Takes RCtrlSOMETHING. Ignores RCtrl0 .. RCtrl9 and bare RCtrl
#_{{
#_    if (Menu.Id == #%FolderShortcutsId) then
#_        Keys("Esc AKey");
#_    end;
#_}}
#_ 
#_ 
#_macro
#_area="Menu"
#_description="Folder shortcuts popup close on second RCtrl or on RCtrl:Release after RCtrl:Hold"
#_key="RCtrl:Release"
#_{{
#_    if (Menu.Id == #%FolderShortcutsId) then
#_        Keys("Esc");
#_    end;
#_}}
#_```
#_
#_</font>
#_
#_[article on forum]: http://forum.farmanager.com/viewtopic.php?f=35&t=7927#p108538
#_[perl converter]: http://code.google.com/p/mini-gnu/downloads/list?can=2&q=2x3
#_[m2l converter]: http://plugring.farmanager.com/plugin.php?pid=884&l=en
#_[move to files]: http://forum.farmanager.com/viewtopic.php?f=35&t=7564
#_[farman macro]: http://forum.farmanager.com/viewtopic.php?f=35&t=7893
#_[SimSU]: http://code.google.com/p/simsufar/downloads/list
#_[SimSU topic]: http://forum.farmanager.com/viewtopic.php?f=15&t=7075
#_[InsertMacro]: http://forum.farmanager.com/download/file.php?id=5665
#_[macrolib main]: http://code.google.com/p/far-plugins/wiki/MacroLib
#_[macrolib dload]: http://code.google.com/p/far-plugins/downloads/list?q=MacroLib
#_[macrolib docs]: http://code.google.com/p/far-plugins/wiki/FML
#_[encyclopedia]: http://api.farmanager.com/ru/
#_[abracadabra]: http://translate.google.com/#ru/en/
#_[translated]: http://translate.google.com/translate?sl=ru&tl=en&js=n&prev=_t&hl=en&ie=UTF-8&eotf=1&u=http%3A%2F%2Fapi.farmanager.com%2Fru%2F
#_[this link]: http://translate.google.com/translate?hl=en&sl=ru&tl=en&u=http%3A%2F%2Fapi.farmanager.com%2Fru%2Fmacro%2Fmacrocmd%2Fprop_func%2Findex.html
#_[lua explorer]: http://forum.farmanager.com/download/file.php?id=5553
#_[thread]: http://forum.farmanager.com/viewtopic.php?f=60&t=7521
#_
</article>
</node>
